[[Solution]]
== Solution

=== Goal

The goal of the extension presented in this report is the improvement of the EMS in order to increase compatibility across existing systems. The EMS provided for Testbed-14 offers a WPS-T 2.0 interface, yet should be able to run multiple application types and use them in heterogeneous workflows. Using a single interface should allow execution of a large array of existing applications and moreover use them inside workflows. Two new application types are considered in this project. The first is for backward compatibility and consist of execution existing process served by WPS 1.0 endpoint. The second is to broaden furthermore the application scope by covering the <<ESGFCompute, ESGF Compute Working Team (CWT) API>>.

=== Architecture

Multiple approaches have been considered to achieve this goal. The first approach is to keep the EMS as is, package every type of application into Docker images, and provide alongside them a CWL describing invocation mechanisms. However, packaging existing providers would yield a huge docker images with multiple processes. This could simply prove impossible for external providers for which the code is unavailable. The second approach, much simpler, defeat however one of the principle of the Testbed-14 which is to bring the application to the data. This approach consist of packaging all the information required to make a standard WPS 1.0 or ESGF CWT API request. A DeployProcess document describing the inputs and outputs of the process is still provided, but the CWL is modified so that the engine can change the execution unit and perform a classic WPS 1.0 or ESGF CWT API execute request, without prior deployment request.

In Testbed-14, CRIM's EMS implementation was all contained in a component named Twitcher. That component is now scinded into two components, so that each one can focus primarily on its own role and make the architecture simpler. The following diagram resume the situation. The WPS-T interface and CWL engine introduced in Twitcher are moved to a new component named Weaver (https://github.com/crim-ca/weaver). Twitcher can now operate as a security proxy along with the permission provider (Magpie) like previously. The relation between the CWL workflow engine, the job interface and all the available implementation for each of the application type are depicted in the following figure.

.New EMS component called Weaver and its workflow packages.
image::images/Twitcher_OGC_DOE.png[width=950,align="center"]

=== Application Package

As mentioned in the previous section, the DeployProcess document is the same for both new application type. It defines an id, inputs, outputs and a CWL execution unit.

.JSON file for a deploy request for CRIM's workflow
[source,json]
----
TODO: Add deploy process json content
----

The CWL file is modified so that the CWL engine can instantiate the appropriate job implementation. To that effect, the hints section of the CWL file are used. This replaces the traditional DockerRequirement value for extensions requirements, which are WPS1Requirement and ESGF-CWTRequirement. Under that key, a dictionary containing all the parameters required to make an execute request to WPS 1.0 provider is added. Below, a CWL example file describes one of the climate processes for the WPS 1.0 provider. The only difference with the CWL provided during Testbed-14 is the hints section declaring the WPS1Requirement and two parameters : the provider endpoint and the process which is wrapped. The file format is also now enforced in the CWL file.

.CWL file for the ice_days process of Finch WPS 1.0 provider
[source,json]
----
{
  "cwlVersion": "v1.0",
  "$namespaces": {
    "edam": "http://edamontology.org/"
  },
  "class": "CommandLineTool",
  "hints": {
    "WPS1Requirement": {
      "process": "ice_days",
      "provider": "https://finch.crim.ca/wps"
    }
  },
  "inputs": {
    "tasmax": {
      "default": {
        "mimeType": "application/x-netcdf",
        "schema": null,
        "encoding": "base64"
      },
      "type": {
        "items": "File",
        "type": "array"
      },
      "format": "edam:format_3650"
    },
    "freq": {
      "default": "YS",
      "type": {
        "symbols": [
          "YS",
          "MS",
          "QS-DEC",
          "AS-JUL"
        ],
        "type": "enum"
      }
    }
  },
  "outputs": {
    "output_netcdf": {
      "outputBinding": {
        "glob": "output_netcdf.nc"
      },
      "type": "File",
      "format": "edam:format_3650"
    },
    "output_log": {
      "outputBinding": {
        "glob": "output_log.*"
      },
      "type": "File",
      "format": "edam:format_1964"
    }
  }
}
----

Since WPS 1.0 provider can describe themselves very well, the process of converting existing provider processes into application packages was automated so that it can be deployed through the EMS. Both the json and cwl are generated automatically. When the CWL engine encounters the file presented above, it is recognized as WPS1Requirement thus creating a WPS 1.0 Job. That job uses the same interface than the WPS-T 2.0 Job, but rather than deploying and executing an application on a remote ADES it call the WPS 1.0 execute request of the provider and process given in parameters. The result is then fetched like for the ADES implementation.

TODO: Talk about CWT app package

=== Application Chaining

For the application chaining, CWL engine is now able to process all type of application only by instantiating the proper job type. To further improve compatibility, utility applications were added. They are small python applications, still packaged as CWL, that can make some adaptation between related type. For example, some application yields json file containing array of netcdf files. The json output is therefore incompatible with an application wanting netcdf files as inputs. The utility application can be chained between the two. This way, the CWL engine feeds the json output into the utility apps that will provide an array of netcdf files, ready to be consumed by the next application. These applications are really lightweight because the CWL file is only wrapping a python function already inside the Weaver EMS component. Below is a sample CWL file of the json to netcdf.

.CWL file for the json to netcdf utility application
[source,json]
----
#!/usr/bin/env cwl-runner
cwlVersion: v1.0
$namespaces:
  iana: "https://www.iana.org/assignments/media-types/"
  edam: "http://edamontology.org/"
class: CommandLineTool
baseCommand: python
arguments: ["-m", "weaver.processes.builtin.jsonarray2netcdf", $(runtime.outdir)]
inputs:
 input:
   type: File
   format: iana:application/json
   inputBinding:
     position: 1
outputs:
 output:
   format: edam:format_3650
   type:
     type: array
     items: File
   outputBinding:
     glob: "*.nc"
----
